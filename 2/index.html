<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CS 180 Project 2: Fun with Filters and Frequencies!</title>
  <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">

  <style>
    body {
      font-family: 'Lato', sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
      background-color: #f9f9f9;
      color: #333;
    }

    .back-link {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 10px 18px;
      font-size: 1em;
      font-weight: 600;
      background-color: #eee;
      border-radius: 6px;
      text-decoration: none;
      color: #333;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      transition: background 0.2s ease, color 0.2s ease;
    }

    .back-link:hover {
      background-color: #ddd;
      color: #000;
    }

    h1 {
      font-size: 3em;
      margin: 60px 0 40px;
      font-weight: 700;
      color: #222;
    }

    .section {
      margin: 10px auto;
      padding: 10px 5px;
      width: 90%;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .section h3 {
      margin-bottom: 20px;
      font-size: 1.8em;
      font-weight: 600;
      color: #111;
    }

    .images {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 40px;
      margin-bottom: 20px;
    }

    img {
      max-width: 600px;
      max-height: 500px;
      border-radius: 10px;
      flex-shrink: 0;
      box-shadow: 0 3px 10px rgba(0,0,0,0.15);
      transition: transform 0.2s ease;
    }

    img:hover {
      transform: scale(1.05);
    }

    .description {
      font-size: 1.1em;
      line-height: 1.7;
      max-width: 1200px;
      margin: 0 auto;
      color: #555;
    }

    .big-img {
      width: 1800px;
      height: auto;    /* keep aspect ratio */
      margin-top: 10px;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <a href="https://eldenyap48.github.io/" class="back-link">‚Üê Back</a>

  <h1>CS 180 Project 2: Fun with Filters and Frequencies!</h1>

  <h2>Part 1: Fun with filters</h2>

  <div class="section">
    <h3>Part 1.1: Convolutions from Scratch!</h3>
    <div class="images">
      <img src="media/convolve2d_4loops.png" alt="Convolve 2D 4-loop implementation">
      <img src="media/convolve2d_2loops.png" alt="Convolve 2D 2-loop implementation">
    </div>
    <div class="description">
      I implemented 2D convolution using a 4-loop function (left) and a 2-loop function (right). The 4-loop function is the slowest because it loops over every single pixel in the image and the kernel. The 2-loop version is faster since it uses Numpy's vectorized operations in the innermost loop. However, both versions are still significantly slower than scipy.signal.convolve2d, which is implemented in optimized C. 

      The functions I implemented always pad the edges with zeros. This could cause artificial dark edges. In contrast, scipy.signal.convolve2d allows users to choose a boundary condition ('fill', 'symm', 'wrap') which could help produce cleaner results at the borders.

      Below are images of myself convolved with the box filter and the finite difference operators.
    </div>
    <div class="images">
      <img src="media/elden.png" alt="Convolved personal image" class="big-img">
    </div>
  </div>

  <div class="section">
    <h3>Part 1.2: Finite Difference Operator</h3>
    <div class="description">
      I convolved the cameraman image with finite difference operators D_x and D_y, and computed the gradient magnitude image as shown below.
    </div>
    <div class="images">
      <img src="media/cameraman.png" alt="Convolved Cameraman" class="big-img">
    </div>
    <div class="description">
      To turn the gradient magnitude image into an edge image, I binarize the gradient magnitude image by setting a threshold of 0.06, allowing us to remove most of the noise and preserve the real edges.
    </div>
    <div class="images">
      <img src="media/cameraman_edge.png" alt="Cameraman edge image">
    </div>
  </div>

  <div class="section">
    <h3>Part 1.3: Derivative of Gaussian (DoG) Filter</h3>
    <div class="images">
      <img src="media/dog_filter.png" alt="Convolution with DoG Filter">
    </div>
    <div class="description">
      I blurred the original image using a Gaussian filter and repeated the procedure above. By using the Gaussian filter G as a smoothing operator, much of the noise could be removed and we can also set the threshold to a lower value of 0.04. The edges in the binarized edge image are also much thicker.

      Next, I did the same thing with a single convolution by creating a derivative of Gaussian filters. The resulting edge image is the same as before as shown above.
    </div>
  </div>

  <h2>Part 2: Fun with Frequencies!</h2>
  
  <div class="section">
    <h3>Part 2.1: Image "Sharpening"</h3>
    <div class="images">
      <img src="media/taj.png" class="big-img">
    </div>
    <div class="description">
      Here are some other images that are sharpened using the unsharp mask filter:
    </div>
    <div class="images">
      <img src="media/machupicchu.png" class="big-img">
    </div>
    <div class="images">
      <img src="media/monteverde.png" class="big-img">
    </div>
    <div class="images">
      <img src="media/torres.png" class="big-img">
    </div>
  </div>

  <div class="section">
    <h3>Part 2.2: Hybrid Images</h3>
    <div class="description">
      Here are some hybrid images:
    </div>
    <div class="images">
      <img src="media/nathan_labubu.png" class="big-img">
    </div>
    <div class="images">
      <img src="media/barbie_rock.png" class="big-img">
    </div>
    <div class="images">
      <img src="media/sloth_dog.png" class="big-img">
    </div>
    <div class="description">
      For the first hybrid image, here is the process illustrated through frequency analysis:
    </div>
    <div class="images">
      <img src="media/nathan_labubu_breakdown.png" class="big-img">
    </div>
  </div>

  <div class="section">
    <h3>Part 2.3: Gaussian and Laplacian Stacks</h3>
    <div class="description">
      I implemented a Gaussian and a Laplacian stack, and applied them to the Oraple:
    </div>
    <div class="images">
      <img src="media/oraple_laplacian.png" class="big-img">
    </div>
  </div>

  <div class="section">
    <h3>Part 2.4: Multiresolution Blending</h3>
    <div class="description">
      Here are some images that have been blended together using both regular and irregular masks
    </div>
    <div class="images">
      <img src="media/oraple.png">
      <img src="media/treeface.png">
      <img src="media/kapybarasky.png">
    </div>
    <div class="description">
      Here is an illustration of the process used to create one of the blended images
    </div>
    <div class="images">
      <img src="media/treeface_laplacian.png">
    </div>
  </div>

</body>
</html>
