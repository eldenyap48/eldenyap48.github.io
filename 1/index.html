<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <a href="https://eldenyap48.github.io/" class="back-link">‚Üê Back</a>

  <h1>CS 180 Project 1: Images of the Russian Empire -- Colorizing the Prokudin-Gorskii Photo Collection</h1>

  <div class="section">
    <h2>Project Overview</h2>
    <div class="description">
      In this project, we take the digitized Prokudin-Gorskii glass plate images and, using image processing techniques, automatically produce a color image with as few visual artifacts as possible.
    </div>
  </div>

  <div class="section">
    <h2>Approach</h2>
    <div class="description">
      For all images, I first split each glass plate into three equal-height channels (B, G, R).
      For low-resolution images, I treated the blue channel as the fixed reference and aligned the red and green channels to it by exhaustively searching integer displacements (dx, dy) in a [-15, 15] window along both the x and y axes.
      For each (dx, dy) shift, I computed a similarity score using the Normalized Cross Correlation Coefficient (NCC), although the helper functions also support the usage of the L2 norm.
      Since the borders of the photograph will have misaligned channels, only the central 80% of the image was used for the score calculation, and the best alignment maximizes NCC (or minimizes the L2 score).
      After choosing the optimal shifts, I rolled the original G and R channels by those offsets and stacked [R, G, B] to produce the final color image (saved as JPEG).

      For the full-resolution glass plate images (.tif files), I used a recursive coarse-to-fine image pyramid with a downscale factor of 0.5.
      The algorithm aligns at the coarsest level, doubles the estimated offsets as it ascends at each level, and performs a small local refinement window at the current resolution.
      This drastically reduces runtime while maintaining accuracy for large image files.

      For difficult cases like the Emir of Bukhara, where cross-channel brightness differs, I aligned on edge features rather than raw intensities.
      I applied a Sobel filter to compute gradient magnitude for scoring with NCC but still applied the resulting shifts to the original channels.
      Edges are more stable across color channels, making NCC more robust in this scenario.
    </div>
  </div>

  <div class="section">
    <h2>Single-Scale Alignment on Low-Resolution Images</h2>
    <div class="images">
      <img src="media/out_single_cathedral.jpg">
      <img src="media/out_single_monastery.jpg">
      <img src="media/out_single_tobolsk.jpg">
    </div>
  </div>
</body>
</html>
